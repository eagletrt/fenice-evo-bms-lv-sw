/******************************************************************************
Finite State Machine
Project: fsm.dot
Description: bms_lv

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.4
Generation date: 2024-01-23 11:59:31 +0100
Generated from: fsm.dot
The finite state machine has:
  6 states
  7 transition functions
******************************************************************************/

#include "bms_fsm.h"

#include "bms_lv_config.h"
#include "can_messages.h"
#include "cooling_control.h"
#include "primary_network.h"

#include <stdint.h>

void lv_error_init(void);
void error_routine(void);
bool error_get_fatal(void);

void adc_routine_start(void);
void monitor_init(void);
void gpio_extender_init(void);
void adc_vrefint_calibration(void);
void buzzer_init(void);
int can_start();

void adc_routine(void);
void can_routine(void);
void gpio_extender_routine(void);
void monitor_routine(void);
bool is_total_voltage_ok(void);
void all_measurements_check(void);
void send_i_am_alive_msg(void);

void primary_lv_errors_send(void);

void buzzer_beep_async(uint32_t buzzer_duration, buzzer_mode_t sound_mode);

int set_led(int led1, int led2, int led3);
void set_time_set(uint8_t status);
void radiator_init();
void dac_pump_init();
void dac_pump_set_status(primary_lv_pumps_speed_status mode);
void radiator_set_status(primary_lv_radiator_speed_status status);
primary_lv_pumps_speed_status dac_pump_get_status();
primary_lv_radiator_speed_status radiator_get_status();

void bms_lv_routine(bool checks_enabled) {
    send_i_am_alive_msg();
    error_routine();
    adc_routine();
    can_routine();
    gpio_extender_routine();
    monitor_routine();
    if (checks_enabled) {
        all_measurements_check();
    }
}

uint8_t inverter_state = 0;
bool flash_requested;
extern primary_ecu_status_converted_t ecu_status;
extern primary_hv_status_converted_t hv_status;

// SEARCH FOR Your Code Here FOR CODE INSERTION POINTS!

// GLOBALS
// State human-readable names
const char *state_names[] = {"init", "idle", "error", "tson", "flashing", "run"};

// List of state functions
state_func_t *const state_table[NUM_STATES] = {
    do_init,      // in state init
    do_idle,      // in state idle
    do_error,     // in state error
    do_tson,      // in state tson
    do_flashing,  // in state flashing
    do_run,       // in state run
};

// Table of transition functions
transition_func_t *const transition_table[NUM_STATES][NUM_STATES] = {
    /* states:      init            , idle            , error           , tson
       , flashing        , run              */
    /* init     */ {NULL, init_to_idle, to_error, NULL, NULL, NULL},
    /* idle     */ {NULL, NULL, to_error, idle_to_tson, idle_to_flashing, NULL},
    /* error    */ {NULL, NULL, NULL, NULL, NULL, NULL},
    /* tson     */ {NULL, tson_to_idle, NULL, NULL, NULL, tson_to_run},
    /* flashing */ {NULL, NULL, to_error, NULL, NULL, NULL},
    /* run      */ {NULL, run_to_idle, to_error, NULL, NULL, NULL},
};

/*  ____  _        _
 * / ___|| |_ __ _| |_ ___
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *
 *   __                  _   _
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */

// Function to be executed in state init
// valid return states: STATE_IDLE, STATE_ERROR
state_t do_init(state_data_t *data) {
    state_t next_state = STATE_IDLE;

    /* Your Code Here */

#if COOLING_TYPE == COOLING_TYPE_PID
    // TODO: set coefficients for PID
    // cooling_pid_init(float kp, float ki, float kd, float sample_time, float anti_windUp);
    cooling_pid_init(0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
#endif

    // cooling OFF
    radiator_init();
    dac_pump_init();
    // discharge ON
    set_discharge(0);
    // rfe/frg OFF
    set_rfe_frg(0);
    buzzer_init();

    // check error codes
    lv_error_init();
    adc_routine_start();
    adc_vrefint_calibration();
    monitor_init();
    gpio_extender_init();
    can_start();

    monitor_routine();
    error_routine();

    uint32_t prevtime = get_current_time_ms();
    while ((get_current_time_ms() - prevtime) < 50) {
        bms_lv_routine(false);
    }

    if (error_get_fatal() || !is_total_voltage_ok()) {
        next_state = STATE_ERROR;
    }

    switch (next_state) {
        case STATE_IDLE:
        case STATE_ERROR:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state idle
// valid return states: NO_CHANGE, STATE_IDLE, STATE_TSON, STATE_FLASHING,
// STATE_ERROR
state_t do_idle(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    // cooling no change
    // discharge ON
    // rfe/frg OFF

    /* Your Code Here */
    bms_lv_routine(true);

    if (hv_status.status == primary_hv_status_status_airn_close) {
        next_state = STATE_TSON;
    } else if (error_get_fatal()) {
        next_state = STATE_ERROR;
    }

    switch (next_state) {
        case NO_CHANGE:
        case STATE_IDLE:
        case STATE_TSON:
        case STATE_FLASHING:
        case STATE_ERROR:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state error
// valid return states: NO_CHANGE
state_t do_error(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    buzzer_beep_async(65535, BUZZER_MODE_NORMAL);

    // cooling OFF
    // discharge ON
    set_discharge(0);
    // rfe/frg OFF
    set_rfe_frg(0);
    primary_lv_errors_send();
    blocking_delay_ms(1000);
    /* Your Code Here */
    // TODO: error code check, [send it via can/write to flash], shutdown
    set_relay(0);

    switch (next_state) {
        case NO_CHANGE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state tson
// valid return states: NO_CHANGE, STATE_IDLE, STATE_TSON, STATE_RUN
state_t do_tson(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    // cooling no change
    // set discharge OFF
    // set rfe/frg OFF
    // until car_status == {...}

    /* Your Code Here */
    bms_lv_routine(true);

    // until car_status == {...}
    // car_status -> drive -> run
    if (ecu_status.status == primary_ecu_status_status_enable_inv_drive) {
        next_state = STATE_RUN;
    } else if (
        hv_status.status != primary_hv_status_status_airn_close && hv_status.status != primary_hv_status_status_precharge &&
        hv_status.status != primary_hv_status_status_airp_close && hv_status.status != primary_hv_status_status_ts_on) {
        next_state = STATE_IDLE;
    } else if (error_get_fatal()) {
        next_state = STATE_ERROR;
    }
    // car_status -> idle -> idle

    switch (next_state) {
        case NO_CHANGE:
        case STATE_IDLE:
        case STATE_TSON:
        case STATE_RUN:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state flashing
// valid return states: STATE_ERROR
state_t do_flashing(state_data_t *data) {
    state_t next_state = STATE_ERROR;

    buzzer_beep_async(65535, BUZZER_MODE_NORMAL);

    // cooling no change
    // set discharge ON
    // set rfe/frg OFF
    // SET TIME_SET ON
    set_time_set(1);
    blocking_delay_ms(16);  // 15.51ms has been calculeted as charge time for the capacitor
    set_time_set(0);

    /* Your Code Here */

    switch (next_state) {
        case STATE_ERROR:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state run
// valid return states: NO_CHANGE, STATE_IDLE, STATE_RUN, STATE_ERROR
state_t do_run(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    // activate automatic cooling
    // set discharge OFF
    // set rfe/frg ON

    /* Your Code Here */
    bms_lv_routine(true);

    // until car_status == run
    if (!(ecu_status.status == primary_ecu_status_status_drive || ecu_status.status == primary_ecu_status_status_enable_inv_drive) ||
        hv_status.status != primary_hv_status_status_ts_on) {
        next_state = STATE_IDLE;
    } else if (error_get_fatal()) {
        next_state = STATE_ERROR;
    }

    switch (next_state) {
        case NO_CHANGE:
        case STATE_IDLE:
        case STATE_RUN:
        case STATE_ERROR:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

/*  _____                    _ _   _
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | |
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_|
 *
 *   __                  _   _
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */

// This function is called in 1 transition:
// 1. from init to idle
void init_to_idle(state_data_t *data) { /* Your Code Here */
    buzzer_beep_async(1, BUZZER_MODE_NORMAL);
    set_rfe_frg(1);
    set_relay(1);
    set_led(1, 0, 0);
}

// This function is called in 4 transitions:
// 1. from init to error
// 2. from idle to error
// 3. from run to error
// 4. from flashing to error
void to_error(state_data_t *data) { /* Your Code Here */
    set_led(0, 0, 0);
}

// This function is called in 1 transition:
// 1. from idle to tson
void idle_to_tson(state_data_t *data) { /* Your Code Here */
    set_discharge(1);
}

// This function is called in 1 transition:
// 1. from idle to flashing
void idle_to_flashing(state_data_t *data) { /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from tson to idle
void tson_to_idle(state_data_t *data) { /* Your Code Here */
    set_discharge(0);
}

// This function is called in 1 transition:
// 1. from tson to run
void tson_to_run(state_data_t *data) { /* Your Code Here */
    set_discharge(1);
    set_rfe_frg(1);
    if (radiator_get_status() == primary_lv_radiator_speed_status_off) {
        radiator_set_status(primary_lv_radiator_speed_status_auto);
    }

    if (dac_pump_get_status() == primary_lv_pumps_speed_status_off) {
        dac_pump_set_status(primary_lv_pumps_speed_status_auto);
    }
}

// This function is called in 1 transition:
// 1. from run to idle
void run_to_idle(state_data_t *data) { /* Your Code Here */
    set_discharge(0);
    set_rfe_frg(0);
}

/*  ____  _        _
 * / ___|| |_ __ _| |_ ___
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *
 *
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|
 *                              |___/
 */

state_t run_state(state_t cur_state, state_data_t *data) {
    state_t new_state = state_table[cur_state](data);
    if (new_state == NO_CHANGE)
        new_state = cur_state;
    transition_func_t *transition = transition_table[cur_state][new_state];
    if (transition)
        transition(data);
    return new_state;
};

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
    state_t cur_state = STATE_INIT;
    do {
        cur_state = run_state(cur_state, NULL);
        sleep(1);
    } while (cur_state != STATE_ERROR);
    run_state(cur_state, NULL);
    return 0;
}
#endif
